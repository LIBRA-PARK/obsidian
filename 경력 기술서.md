# 인터페이스 리소스 및 거래 관리 및 배포 통합 API 개발
(주)TmaxSoft, Interface Core 파트 - 연구원
2024.04 ~ 2024.08

## 설계 목적
현 프레임워크 `AnyLink 7`은 인터페이스 운영하기 위한 세션(`Adapter`, `Endpoint` 등)과 BPMN 정의(`Transaction`, `Flow`)하고 실제로 실행되는 엔진에 리소스를 배포하며, 본 과정은 세션을 정의하는 `Admin Web Application` 과 BPMN 정의하기 위해 이용되는 `Ecplipse IDE Applciation` 총 2개의 애플리케이션을 통해서 수행된다.

![[Pasted image 20240906190434.png]]

상이한 `Web`과 `Eclipse IDE` 환경은 편의와 이슈 대응 속도 저하를 유발 하는데, 두 환경에 대한 리소스가 공유되지 않기에 인터페이스 구축을 위해선 빈번한 애플리케이션 이동으로 발생한다. `Web Application`의 경우에는 데이터베이스에 `Eclipse IDE Application`은 로컬 폴더에 리소스가 저장 및 관리 되어 엔진에 배포되기 전 까지 유효성을 검사할 수 없다. 이 구조로 운영 지원 파트는 사이트에 대한 운영을 위해서 두 애플리케이션을 직접적으로 사람이 검사하는 과정이 필요하고, 인터페이스를 실행하기 위한 과정이 증가한다. 또한, 배포되기 전 까지 인터페이스에 대한 유효성을 판단할 수 없기 때문에 온전히 담당자에 의해서 결과가 결정된다. 이 결과로 휴먼 에러가 발생될 확률이 높아지고 이슈가 발생될 경우 세션 또는 BPMN 정의의 문제인지 아니면 배포 상 오류 인지 에러 영역을 판단할 수 없어 개발 팀에서는 대응을 위해서는 이슈 상황과 동일한 인터페이스를 배포한 후 통합 디버깅을 진행하는 문제를 야기했다.

 문제 정의
+ 작업 흐름의 비효율성
	+ 정상적인 프레임워크 이용을 위해 `Web` 과 `Eclipse IDE Application` 간 빈번한 이동이 필요하다는 점
+ 휴먼 에러 발생 가능성 증가
	+ 서로 상이한 환경의 애플리케이션에서 리소스 공유하지 못해 배포 전까지 유효성 검사가 진행되지 못해 담당자가 모두 수동으로 검사를 진행
+ 이슈 분석 및 대응 속도 증가
	+ 문제가 발생될 경우 세션, BPMN 정의 인지 배포 상 문제가 발생한 것이지 판단하기 어려워 이슈 대응에 시간이 많이 소요되고 원인 분석을 위해 통합 디버깅 과정 강제됨

## 해결 과정
본 문제점들을 해결하기 `Eclipse IDE Application`에서 이용되는 리소스(`Transaction`, `Message` 등)를 동일한 데이터베이스에 저장했다. 이 리소스는 세션과 동일하게 계층적 구조로 데이터베이스에 쉽게 추가했다. 다만 XML 파일 형식의 데이터를 가지는 BPMN Flow 의 경우에는 그 형식을 스키마로 정의할 수 없어 `BLOB` 컬럼을 사용해 `Key-Value` 저장 방식을 채용해 저장했다. 이로써 동일한 환경에서 데이터를 공유하기에 `Outbound Rule` 같이 세션의 리소스를 참조해 정의되는 경우 유효성 체크를 진행할 수 있어 저장에서 발생될 수 있는 휴먼 에러를 방지할 수 있었다.

그리고 `Eclipse IDE Application` 의 주된 기능인 배포를 API로 개발해 통합 API 서버를 개발하여 작업 흐름의 비효율성을 줄이고자 했다. 이를 위해서 배포 서비스가 호출 전 이벤트와 기능들을 분석과 역할을 세분화해서 파악했고, 배포 전 엔진에서 동작할 수 있는 상태로 리소스를 변환(`.java`) 및 컴파일(`.class`) 하는 과정이 프레임워크에서 인터페이스를 동작하기 위한 필수다.

![[Pasted image 20240910122928.png]]

+ Code generation (FreeMarker)
	+ XML로 저장된 리소스를 Java 컴파일을 진행할 수 있도록 .java 파일로 변환
+ Java Compile (javax.tools.JavaCompiler)
	+ 변환된 .java 파일에 컴파일을 통해서 .class 파일 생성

위 과정을 거쳐서 생성된 `.class` 파일의 집합을 `Interface Execute Engine` 전송해 `ClassLoader` 에 `Class`  적재시켜 `Engine`에 들어오는 요청을 정의된 인터페이스로 실행하게 되는 것이다. 따라서, 본 두 과정을 서비스로 구현해 통합 API서버에 Deploy API의 서비스로 이식했다. 구현된 API는 기능 테스트를 진행해 정상적으로 `Code generation` 과정과 `Java Complie` 과정을 거쳐서 최종적으로 `Engine`에서 동작할 수 있는 파일 집합을 구성할 수 있었다.

하지만, 다중 배포 API와 규모가 큰 인터페이스에 대해서 구현된 API를 호출할 경우 `Code-generation` 이며 `Complie`  서비스 실행 시간이 길어지기 때문에 API 의 타임아웃을 초래했다. 타임아웃 기준을 늘리는 것은 해당 요청이 런타임 에러로 멈추었는지 실행 중인지 판단할 수 없기 때문에 오히려 편의성 측면에서 방해가 되며, 늘리는 것은 본 문제를 본질적으로 해결한 것이기 아니기 때문에 다른 방안으로 구현했다.

배포 전에 발생되는 이벤트를 비동기 이벤트 처리 방식과 MSA 구조로 설계해 별도의 애플리케이션으로 처리될 수 있도록 변경해, Deploy API 호출을 즉각적인 응답이 아닌 비동기 이벤트 명령을 전달하는 API로 변경했다. 사용자는 배포 결과 대한 정보를 즉각적인 응답으로 받을 순 없으나, 별도의 조회 API를 이용해서 결과 및 현황에 대한 정보를 제공 받을 수 있도록 변경했다.

![[Pasted image 20240910133720.png]]
+ Compile Application 
	+ 생성된 `.java` 파일에 대해서 `Complie`해 `.class` 파일을 생성
+ Code-gen Application
	+ 배포 요청된 Transaction에 사용되는 리소스를 데이터베이스로 조회 후 로컬 폴더에 `.java` 파일을 생성
+ Deploy Application
	+ 생성된 `.class` 파일을 하나의 압축하여 지정한 `Interface Execute Engine` 정보를 데이터베이스로 조회한 후 해당 주소로 리소스 전송
+ Error Application
	+ 모든 애플리케이션에서 `Exception` 또는 에러가 발생 될 경우 `Error Message`를 `Queue`에 추가해 그 뒤의 롤백 로직을 `Error Application`에서 진행될 수 있도록 설계했다. 따라서 본 `Error Application`은 에러나 예외에 대한 케이스 별로 해당되는 롤백 로직을 수행

배포 API로 시작되는 이벤트에 대한 상태 추적과 예외 관련된 정보를 조회하기 위해서 데이터베이스에 `Transaction` 과 `Trace` 테이블을 생성 후 `Transaction` 과 `Trace` 가 1:N 관계를 가지도록 코드 레벨에서 구현했다. 그리고 Deploy API 호출 시 UUID를 통해서 ID를 발급 받고 `Transaction` 테이블로 `INSERT`하고 `Message Queue Header` 활용해 각 애플리케이션에서 발급 받은 `Transaction ID`를 기반으로 이벤트 처리된 결과 및 예외를 `Trace` 테이블에 `INSERT` 구조로 구현했다.

## 결과
통합 API 서버 개발로 리소스가 공유되지 못하던 문제와 배포 프로세스의 대한 작업 흐름 비효율성을 개선하고 유효성을 체크를 보장하여 휴먼 에러를 감소 시킬 수 있도록 개선하게 되었다. 개선되는 새로이 발생한 API 타임 아웃 문제에 직면했을 때는 프로젝트의 구조를 MSA 구조로 변경하고 API에 대해서 비동기 이벤트 처리 방식으로 개선하여 해결했다. 

+ 통합 인터페이스 프레임워크 개발
	+ 별도의 `Web`과 `Eclipse IDE Application` 환경이 아닌 프레임워크의 모든 서비스를 제공해줄 수 있는 `Web` 환경으로 제공할 수 있도록 프레임워크 개발
+ 프레임워크 리소스 생성과 수정 단계에서 유효성 체크 기능 제공
	+ 프레임워크의 실행 주체가 되는 `Endpoint`, `Transactional` 같은 리소스에 대해서 유효성 검사 기능을 제공해 발생할 수 있는 휴먼 에러 발생 제거
+ 비즈니스 로직관련 세분화로 유지 보수성과 편의성 개선
	+ 배포 단계에서 소요되는 `Code-generation`와 `Compile` 단계를 별도의 애플리케이션에서 서비스를 작성함으로써 코드의 가독성 확보와 이슈 대응 시 명확한 트러블 영역을 제공해 유지보수성을 확보
	+ 배포 단계에서 발생한 `Exception`및 에러에 대한 `Trace` 제공할 수 있는 배포 현황과 배포 이력 서비스를 제공함으로써 운영 단계에서 원인 분석할 수 있도록 사용성 개선

# Kubernetes 테스트베드 자동 구축 API 서버 개발
(주)TmaxSoft, Interface Core 파트 - 연구원
2024.06 ~ 2024.08
## 설계 목적
인터페이스 프레임워크는 사이트 별 데이터베이스, JDK 버전 등 운영되는 환경이 상이하게 달라서 이슈가 발생될 경우 대응할 수 있도록 동일한 환경이 필요하다. 그리고 B2B는 주기적인 업데이트가 존재하지 않고 운영 사이트 별로 배포된 Build 버전이 상이함. 이에 따라서 이슈가 발생할 경우 Build 버전을 고려해 동일한 환경을 구축해서 이슈에 대한 분석을 진행해야 한다.


![[Pasted image 20240910151249.png]]


이슈를 분석하기 위해선 이슈가 발생한 인터페이스를 다운로드 후 동일한 환경에 인터페이스를 배포하여 해당 이슈를 재현한다. 이슈 분석에도 통합 디버깅이다 보니 오랜 시간이 소요되는데 이슈 도중 다른 이슈에 대한 추가 검증이나 분석 요청 또는 긴급 이슈로 분석 환경이 변경되는 경우가 발생하게 되면 다시 환경을 변경하는 번거로운 과정이 발생한다. 

이슈에 대한 보고는 운영 파트에서 고객의 사이트 환경에서 발생된 이슈를 환경과 함께 보고한다. 그리고 리포트된 이슈를 1차적으로 QA 파트에서 검증한 후 재연된 시나리오를 전달해주어 이슈가 대응되는 프로세스이다. 하지만 여기서 대두되는 문제는 인터페이스에 대한 이슈 불일치 현상으로, 운영, QA 그리고 개발 파트 간 재연이 불일치하는 현상이 발생할 수 있는데, 이럴 경우 원인에 대해서 상정할 수 없어 이슈 대응 시간이 기하급수적으로 증가한다.

이 불일치 현상은 운영 사이트와 QA 파트와 개발 파트 간 분석하는 환경이 상이해서 발생된다. 인터페이스 프레임워크는 JDK와 데이터베이스 심지어는 배포된 인터페이스나 정의된 세션에 정보에 따라서 인터페이스의 결과가 다르게 나올 수 있다. 따라서 각 파트는 최대한 환경에 대한 정합성을 이슈 리포트 정보를 토대로 유지하려고 했으나, 이슈 리포트에 올라오는 잘못된 정보로 파생되는 휴먼 에러를 피할 순 없었다. 

또한, 데이터베이스의 경우에는 개발 파트는 환경 구축에 편의성과 시간을 단축하고자, 파트 내에서 Vendor별로 지정된 데이터베이스를 공유해서 사용했다. 이로 인해서 인터페이스 정의가 겹치거나 설정이 덮어쓰는 경우는 인지하지 못하는 경우가 종종 발생했다.

 문제 정의
+ 환경 불일치로 발생되는 이슈 재연 불가 현상
	+ 각 파트에서 프레임워크가 동작되는 환경이 서로 상이하여 동일한 인터페이스임에도 이슈가 재연이 안되는 현상이 발생 됨, 이 경우 이슈 대응 시간이 크게 지체
+ 이슈 리포트 환경 정보의 대한 휴먼 에러
	+ 환경 불일치를 막기 위해서 환경 정보에 대한 정합성을 유지하려고 했으나, 이슈 리포트가 사람이 작성하기에 휴먼 에러가 발생
+ 비효율적인 환경 전환
	+ 이슈 대응 시 다른 이슈나 긴급 이슈에 대한 분석 요청이 발생할 경우 환경을 다시 설정하는 비효율적 환경, 반복적인 환경 전환은 예기치 못한 에러 발생과 분석 효율성 감소

## 해결 과정
이슈 재연 불가 현상과 환경 정보 정합성을 유지하기 위해서 환경을 구축하는데 인적인 요소를 최소화하고, 이슈 담당자 간 독립된 환경을 구성해 충돌로 발생되는 문제를 방지했다. 그리고 비효율적인 환경 전환 문제를 해결하기 위해서 이슈 간 환경을 쉽게 설정할 수 있고 변경할 수 있도록 하는 Kubernetes 자동 배포 API를 개발했다.

자동 배포 API는 설계는 크게 아래 3개의 주요 서비스로 기반으로 구현했다. 
+ Issue Configuration Service
	+ 사이트 또는 이슈 간 실행되는 Build 버전이나 Java 파라미터 값을 상이하기에 쉽게 조정할 수 있는 서비스
	+ 이슈 대응에 필요한 환경 정보를(환경변수 및 JAVA 파라미터) 설정하는 서비스를 담당한다. ID 값을 기반으로 생성될 환경의 독립성을 보장하고 필요한 JDK 버전 정보와 Clone Repository 선정하고, 추가적으로는 프로젝트의 빌드 형식이나 실행된 주소 또한 설정할 수 있다. 본 서비스는 API 의 Gateway 역할을 담당하며 요청 정보를 기반으로 실행의 주체가 될 엔티티 `Issue` 생성하고 테이블의 INSERT 역할
+ Version Control Service
	+ 프레임워크가 저장된 Repository에서 clone 하거나 Build 버전에 맞춰 checkout / fetch 기능
	+ `Issue` 엔티티 설정 값을 기반으로 Local Working Directory에 Repository를 Clone 하여 이슈에 이용될 프로젝트를 생성한다. 만약 브랜치 변경이나 업데이트 API가 호출될 경우 생성된 프로젝트에 checkout / fetch 명령어 수행을 담당하는 역할
+ Kubernetes Service
	+ 각 Build 버전 별로 Kubernetes 환경에 배포 기능과 프로젝트에 연동되는 JDK와 데이터베이스를 기반으로 Docker 파일 빌드 및 생성 기능
	+ `Issue` 엔티티 설정 값 중 JDK 버전과 Java Project Build Type 을 기반으로 Docker File을 Code-generation로 생성 한 후 Kubectl 을 통해서 Cloud 환경에 배포 역할

![[Pasted image 20240910142105.png]]
`Version Control Service` 과 `Kubernetes Service`는 단순 API 작성 된 경우 Repository의 크기가 커지게 되면서 타임아웃을 발생시켜, 중앙 Message Queue를 배치해 MSA와 비동기식 이벤트 처리방식 구조적으로 변경해 구현했다. 

![[Pasted image 20240909173408.png]]
`Version Contorl Service`에 의 경우에는 clone / fetch / checkout 명령어를 수행할 수 있도록 처음에는 ProcessBuilder를 통해서 curl 명령어를 호출하여 Git 명령어를 Local Working Directory에서 수행토록 했다. 하지만 curl 명령어 구현 방식은 서비스 로직에 가독성 및 에러 처리가 까다로워 Jgit 사용하여 재구현했다. 정상적으로 Git 명령어가 수행될 경우 `Kubernetes Service`로 다음 이벤트를 처리할 수 있도록 `Kube Message`의 헤더에 Local Working Directory 경로를 헤더에 설정한 후 Queue에 Message를 등록한다. 그리고 Issue 엔티티의 상태를 SUCCEED_CLONE 으로 변경하여 전체 이벤트 상태를 알 수 있도록 했다.

![[Pasted image 20240909173403.png]]
`Kubernetes Service`는 전달 받은 Message의 Header에 있는 Local Working Directory 경로에 접근해 Code-generation 서비스를 이용해서 Docker 파일을 빌드했다. 하지만 초기 개발에서 FreeMarker를 이용해 DockerFile은 만들 경우 프로젝트 별로 Docker 파일을 생성 과정을 거쳐, 생성된 Docker 파일과 프로젝트 파일을 Build해 Container 이미지로 만든 후 Kubernetes 환경에 밀어 넣어야했다. 이렇듯 최종 Container 이미지 생성까지 많은 프로세스가 발생하고 서비스 개발인 아닌 FreeMarker 를 작성하는데 더 많은 시간이 소모되었다.

그래서 구글의 jib를 활용해서 자바 앱을 컨테이너화를 하도록 변경했다. 변경된 서비스는 자바 프로젝트의 Groovy Gradle, Kotlin Gradle 또는 Maven 에 jib 코드를 주입하여 명령어를 실행 시켜 경우, 프로젝트를 Container Image 변환 후 자동적으로 Container 업로드 되도록 구성했다.

그리고 Deployment API가 호출될 경우 업로드된 Container image를 Issue 엔티티 값을 기반으로 Kubernetes 환경 내에서 namepsace 와 pod 그리고 service를 만들어 배포한 후 외부 접속 가능한 주소 정보를 반환하도록 했다.

## 결과
Kubernetes 테스트베드 자동 구축 API 서버를 개발해 파트 내에서 운행한 결과
* 이슈를 대응하기 위해서 환경을 손쉽게 생성하고 제거 가능하도록 개선했고, 특히 이슈 별 독립된 환경으로 스위칭 가능 하도록 개발해 이슈 대응 시간 줄일 수 있었음
* 지속적으로 사용하면서 개선한 방안들을 찾고 QA 파트에 제공하여 협업 환경에 대해서 구축된다면, 이슈 대응 속도를 현저히 감소할 수 있을 것

# 'AnyLink 7' 프레임워크 문제점 개선 - 유효성 보장 설계
(주)TmaxSoft, Interface Core 파트 - 연구원
2024.01 ~ 2024.06
## 설계 목적
`AnyLink 7`의 경우에 String 과 BLOB 자료형으로 구성된 각 `SYS_ID` 와 `CONTENTS` 두 개의 컬럼으로 비정형 데이터 저장 방식을 채용 후 Key-Value 구성하여 프레임워크에 필요한 자원을 XML또는 JSON, Byte 형식으로 변환해 저장 및 운영되도록 구성되어있었다. 

![[Pasted image 20240906180848.png]]

본 방식을 채용한 프레임워크는 단순히 직렬화 된 데이터를 `CONTENTS` 컬럼에 저장 시 요구 사항에 대해서 대응할 수 있기 때문에, 역직렬화 될 자바 클래스 객체만 잘 관리한다면 추가적인 데이터베이스 작업이나 스키마 변경에 영향을 받지 않아 좋은 유연성과 확장성을 보장할 수 있다. 이 구조로 인터페이스 프레임워크는 요구 사항과 추가적인 서비스를 유연하게 확대되어 오면서 운영되어왔다. 

그 결과 현재는 `Endpoint` 또는 `Interface Transaction`에 대해서 설정할 수 있는 옵션을 100 ~ 180 개를 지원해 타사 제품과 달리 넓은 편의 기능을 지원하는 프레임워크가 될 수 있었다. 하지만, 이 결과는 높은 확장성을 보장했다고 말할 수 있지만 이면으로는 데이터가 무분별하게 확장되고 비즈니스 로직에 필요한 객체가 비대 해져 코드 레벨에 가독성과 유지 보수성을 저하시켰다. 특히 전체 데이터를 역직렬화 하는 과정이 성능에 영향일 미치기 시작했고, 코드 레벨에서 리소스 간의 관계 파악 점차 어려워지기 시작해 이슈 대응 속도를 저해시켰다.

실제로 이슈 대응과 신규 기능 개발 업무를 맡아온 약 2년 간 이슈들은 복잡하게 구성된 인터페이스의 정상적인 실행 결과에 대한 문의와 분석을 요청하는 부분들이 다소 많았다. 가장 크게 대두되었던 문제는 장기간 운영된 사이트에서 인터페이스를 생성 및 수정 시 누적되어 왔던 리소스들의 유효성에 대해서 판단할 수 없어 배포가 되지 않거나 정상적인 실행이 되지 않았다. 이에 따라서 정상적으로 배포 및 실행이 될 수 있도록 분석하는 이슈도 기하급수적으로 파생되었다.

데이터가 Key-Value 방식으로 저장된 방식은 필터링, 검색 기능 같이 편의성 개선을 위한 신규 서비스를 제공하기 위해선 반드시 전체 데이터를 역직렬화 한 후 구현에 필요한 필드만 가져와야 하는 불필요한 단계가 필요하다. 이 역직렬화 과정은 관리되지 못하는 자원이 누적될수록 서비스의 성능의 저하를 유발하는 것은 물론이며 편의 기능을 구현하기 위해서 중복된 데이터를 별도의 컬럼으로 삽입하는 등 역정규화를 유발했다.

문제정의
+ 리소스 데이터 비대화 및 복잡성 증가
	+ 비정형 데이터를 저장 방식으로 유연성과 확장성은 확보하였으나, 점진적으로 데이터와 역직렬화 객체가 점차 비대해져 비즈니스 로직에 가독성을 저해
	+ 무분별한 확장으로 인해서 데이터베이스에서 각 리소스들의 관계를 명확하게 파악이 불가능하며, 저장된 데이터를 역직렬화 과정의 서비스도 점차 복잡해지기 시작하면서 코드 유지 보수성이 감소
+ 역직렬화 과정에서 발생되는 성능 및 구현 단계 저하
	+ 저장된 데이터는 역직렬화 과정이 요구되었으며 신규, 편의 기능을 구현에 해당 필요한 필드만을 추출하기 위한 객체를 추가하거나 전체 역직렬화 후 필요 객체만 추출해야하는 과정으로 서비스의 성능을 저하 및 코드의 복잡성을 증대
	+ 본래의 구조로 성능을 고려한 구현이 필요할 경우 역직렬화를 우회하는 방안으로 테이블에 중복 데이터를 새로운 컬럼으로 추가하는 역정규화 과정이 발생됨
+ 운영 효율성 저하
	+ 장기간 운영된 사이트에서 인터페이스 생성 및 수정 시 누적된 리소스들의 유효성을 검사하지 못하면서 연쇄 작용으로 배포가 되거나 정상적인 실행이 안됨, 이에 분석을 요청하는 이슈가 파생됨 개발 및 운영에 대한 효율성을 저하

## 해결 과정
점진적으로 리소스 데이터가 비대화되고 복잡성이 증가하는 문제를 완화하고자 비정형 데이터 저장 방식을 지양하고 테이블 관계를 명확하게 정의하도록 했으며, 운영되는 사이트별 이용하는 데이터베이스 Vendor 의 차이에 대해서 호환성을 위해서 ORM을 적극적으로 활용해 프로젝트를 구성했다.

![[Pasted image 20240909114021.png]]

ORM을 활용한 테이블을 구성하기 위해 Spring Data JPA 이용해 Entity 만들기로 했으며, 본 과정을 위해서 기존 비정형 데이터 방식으로 저장된 리소스를 정규화 통해서 관계를 명확하게 재구성했다. GROUP 에서 GROUP을 가지는 순환 참조를 구성하고 ENDPOINT 가 설정된 프로토콜(FTP,HTTP,TCP 등)과 방향(Outbound, Inbound, Both) 에 따라서 설정 값을 상이 하다는 점을 고려해 개별적으로 구성했다. 최종적으로 관리할 테이블과 컬럼이 기존보다 증가했지만 문제를 야기하던 비대한 리소스 데이터를 세분화하고 역정규화된 데이터를 모두 제거해 데이터베이스를 통해서 리소스간 명확한 관계가 표현되었다.

여기에 데이터베이스의 외래키와 참조 무결성을 확실히 보장하기 위해`@OneToMany` 와 `@ManyToOne` 같은 연관 관계 어노테이션을 이용해 연관 관계를 도입해, 관계가 명확한 리소스일 경우 하위 데이터에 쉽게 접근 할 수 있었다. 이로써 리소스는 관계성 및 외래키에 대해서 ORM이 대신해서 보장할 수 있어, 개발적 고민은 데이터베이스에 관련해서 추가적인 작업이 요구되지 않기에 서비스 코드에 대한 가독성 및 유지 보수성에 집중되었다.

```java
//양방향 매핑
@Entity  
@Getter  
@Table(name = "ADAPATER")  
public class Adater { 	
	@OneToMany(mappedBy = "adapter", cascade = CascadeType.ALL, orphanRemoval = true)
	private List<EndpointGroup> groups;
	
	//생략 
}

@Entity  
@Getter  
@Table(name = "GROUP")  
public class EndpointGroup{  
    //생략 
  
    @ManyToOne  
    @JoinColumn(name="ADATPER_ID",  nullable = false)  
    private Adapter adapter;  
  
    @ManyToOne(fetch = FetchType.LAZY)  
    @JoinColumn(name="PARENT", referencedColumnName = "GROUP_ID")  
    private EndpointGroup parent; 

  }
```

하지만 양방향 연관관계 매핑 사용 시 관계를 관리 해야 하는 코드가 Entity 내에 추가되고 비즈니스 로직 코드 작성 시 연관 관계를 상시 관리 해주어야 정상적으로 데이터가 저장되거나 개발자가 의도치 않은 쿼리가 발생되는 문제가 있다. 이 문제로 양방향 관계 매핑은 비즈니스 로직 구현을 위해 서비스를 구현하는데 있어서 Application code level 보다 연관 관계 매핑에 집중 해야하는 문제가 발생했고, 복잡한 비즈니스 로직 구현을 위해서 리소스별 서비스를 호출하는데 있어 트랜잭션의 범위가 커지는 현상이 발생했다. 오히려 편의성을 챙기려다 의도치 않은 쪽으로 코드의 가독성이 망가진다고 판단되어 양방향 관계를 모두 제거했다.

양방향 매핑을 사용하지 않고 한 쪽 객체에만 연관 관계를 유지할 수 있도록 변경해 관계 코드를 최소화하고, 개발자가 집중해야 하는 객체를 줄임으로써 오로지 비즈니스 로직을 위한 서비스 구현에 신경쓸 수 있도록 양방향 매핑을 모두 단방향 매핑으로 변경했다. 변경함으로써 엔티티간 관계를 위한 코드가 mappedBy 삭제되며 두 개의 관계로 맺어진 객체가 하나의 관계로 맺어져 결합도를 감소시켰다. 

이 선택으로 복잡한 비즈니스 로직이 요구되는 API를 작성하거나 프로토콜에 따른 `Adapter` 또는 방향성에 따른 `Endpoint` 서비스를 정의할 때 관계가 맺어진 객체가 없어짐으로써 본 객체만 신경쓰기 때문에 기능의 확장성 및 유연성 그리고 양방향에 비해서 하나의 객체에만 트랜잭션을 정의하기에 범위를 축소 할 수 있었다.

```java
//단방향 매핑
@Entity  
@Getter  
@Table(name = "ADAPATER")  
public class Adater { 
	//생략
}

@Entity  
@Getter  
@Table(name = "GROUP")  
public class EndpointGroup{  
    //생략 
    @ManyToOne  
    @JoinColumn(name="ADATPER_ID",  nullable = false)  
    private Adapter adapter;  
  
    @ManyToOne(fetch = FetchType.LAZY)  
    @JoinColumn(name="PARENT", referencedColumnName = "GROUP_ID")  
    private EndpointGroup parent;  
  }
```


하지만, 단방향 매핑은 복합적 리소스 사용을 요구하는 API 구현 시 객체 지향적 구현 보다는 데이터베이스에 중심적으로 서비스가 구현되는 문제를 유발했다. 개발된 예로 전체 인터페이스 스켈레톤을 한 번에 정의할 수 있는 기능을 제공하게 될 경우, 외래키를 고려해서 순차적으로 INSERT 한 후 다음 하위 리소스를 `INSERT` 해야 정상적으로 동작했다. 단순 C.R.U.D 작업에서는 관계 매핑의 이점이 부각되었지만 복잡한 서비스를 수행하는 API에서는 구현에 대한 집중보다 데이터베이스의 흐름에 더 집중되는 문제가 부각되었다. 이 구조적 설계는 데이터베이스 관점에서 리소스 관계성은 명확하게 알 수 있지만 트랙잭션 범위가 확대되거나 복잡한 서비스에서 자바 구현 레벨에서는 객체 지향적 유연성을 저해시키는 문제가 있었다.

그리고 운영 파트에서는 수작업으로 데이터를 변경하거나, 각 사이트에서 외래키를 제한하는 요건이 간혈적으로 요청되어 외래키 사용하지 않고 구현이 요구되어, 연관 관계를 모두 제거한 후 외래키를 배제하고 프레임워크는 데이터베이스 의존적이지 않고 오로지 구현 단계에서 객체 중심적으로 서비스를 개발할 수 있도록 방향을 변경했다. 그리고 데이터베이스에서 무결성에 대한 책임을 애플리케이션 레벨으로 이동시켜 API의 트랜잭션에 초점을 맞추도록 변경했다.

각 사항을 고려했을 때 객체의 고유 값(`ID`)을 간접적으로 참조하는 방식으로 구조를 변경해, 객체의 구성은 연관 관계보다 결합도는 더 느슨해져 신규 서비스 구현 시 데이터베이스 제약이 사라져 기획과 객체의 생성과 서비스의 구조와 같이 전체 비즈니스 로직의 방향성을 의도한 대로 API 구현 할 수 있었다.
```java
//간접 참조방식
@Entity  
@Getter  
@Table(name = "ADAPATER")  
public class Adater { 
	@Id @GeneratedValue(strategy = GenerationType.IDENTITY)  
	@Column(name = "ADAPTER_ID", updatable = false, nullable = false)  
	private Long id;  
	//생략
}

@Entity  
@Getter  
@Table(name = "GROUP")  
public class EndpointGroup{  
    //생략 
    @Column(name = "ROUTING_TYPE", nullable = false)  
    @Enumerated(EnumType.STRING)  
    private RoutingType routingType;  
   
    @Column(name="ADATPER_ID",  nullable = false)  
    private Long adapterId;  
  
    @Column(name="PARENT")  
    private Long parentId;  
  }
```

## 결과
+ 프레임워크 내 리소스(`Endpoint`, `Adapter` 등) 관리 시 휴먼 에러가 발생을 제거하기 위해서, 사전 유효성 서비스를 제공하여 API 개발
	+ 예를 들면 배치된 `Adapter` 과 다른 프로토콜 및 방향을 가지는 `Endpoint`를 하위 리소스로 생성 되지 않도록 해, 인터페이스가 배포되기 전에 오류가 발생될 수 있는 위험성이 있는지 체크
+ 간접 참조 방식 도입을 이용해 프레임워크 서비스 로직 데이터베이스 제약 감소로 사용자 친화적 서비스 개발 및 구현 레벨의 유지 보수성 확대
	+ 인터페이스 배치 및 각 파싱 옵션에 대해서 스켈레톤 에디터로 한 번에 생성될 수 있는 API 개발, 배포 전 단계까지 통합되었던 API를 세분화하여 워크스루 방식 서비스를 제공해 프레임워크 이용성 증대
	+ 비정형 데이터 저장 방식을 지양하며 간접 참조 방식을 도입해 객체 간 결합도를 낮추고 데이터베이스에 대한 제약이 구현 레벨 코드에서 표현되지 않도록 함
	+ 각 API 행위에 대한 코어 로직에 리소스들의 `Entity` 서비스를 조합해 구현해 코드의 가독성 및 객체 지향적 코드 확보로 유지 보수성 확대